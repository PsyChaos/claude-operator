name: Release

on:
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: write

jobs:
  validate-and-release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate semantic version tag
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "Detected tag: $TAG_NAME"

          if [[ ! $TAG_NAME =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "❌ Invalid tag format. Use vMAJOR.MINOR.PATCH"
            exit 1
          fi

          echo "✅ Tag format valid"

      - name: Ensure required files exist
        run: |
          test -f operator.sh || (echo "operator.sh missing" && exit 1)
          test -f Makefile || (echo "Makefile missing" && exit 1)
          test -f install.sh || (echo "install.sh missing" && exit 1)
          test -f README.md || (echo "README.md missing" && exit 1)
          echo "✅ Required files present"

      - name: Stamp version into operator.sh
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          sed -i "s/^OPERATOR_VERSION=.*/OPERATOR_VERSION=\"$TAG_NAME\"/" operator.sh
          grep "OPERATOR_VERSION=" operator.sh
          echo "✅ Version stamped: $TAG_NAME"

      - name: Import GPG signing key
        run: |
          # Setup GPG for headless/CI operation
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg
          echo "allow-loopback-pinentry" > ~/.gnupg/gpg-agent.conf
          echo "no-tty" >> ~/.gnupg/gpg.conf 2>/dev/null || echo "no-tty" > ~/.gnupg/gpg.conf
          gpg-connect-agent reloadagent /bye 2>/dev/null || true

          # Import key — strip passphrase if present so CI doesn't need to prompt
          echo "${{ secrets.SIGNING_KEY }}" | base64 -d > /tmp/signing.key
          gpg --batch --import /tmp/signing.key
          rm -f /tmp/signing.key

          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG \
            | grep '^sec' | awk '{print $2}' | cut -d'/' -f2 | head -1)
          echo "GPG_KEY_ID=$GPG_KEY_ID" >> $GITHUB_ENV
          echo "Signing key imported: $GPG_KEY_ID"

      - name: Generate checksums and signatures
        run: |
          # Checksums
          sha256sum operator.sh > operator.sh.sha256
          sha256sum install.sh  > install.sh.sha256
          for f in profiles/*.md; do
            sha256sum "$f" > "$f.sha256"
          done

          # GPG signatures — loopback pinentry, passphrase from secret (empty if not set)
          sign() {
            gpg --batch --yes \
                --pinentry-mode loopback \
                --passphrase "" \
                --detach-sign --armor \
                --local-user "$GPG_KEY_ID" "$1"
          }
          sign operator.sh
          sign install.sh
          for f in profiles/*.md; do
            sign "$f"
          done
          echo "✅ Checksums and signatures generated"

      - name: Collect release assets
        run: |
          # Build file list dynamically — picks up any new profiles automatically
          {
            echo "operator.sh"
            echo "operator.sh.sha256"
            echo "operator.sh.sig"
            echo "install.sh"
            echo "install.sh.sha256"
            echo "install.sh.sig"
            echo "claude-operator.gpg.pub"
            for f in profiles/*.md; do
              echo "$f"
              echo "$f.sha256"
              echo "$f.sig"
            done
          } > /tmp/release-files.txt
          echo "Release assets:"
          cat /tmp/release-files.txt

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          files: |
            operator.sh
            operator.sh.sha256
            operator.sh.sig
            install.sh
            install.sh.sha256
            install.sh.sig
            claude-operator.gpg.pub
            profiles/*.md
            profiles/*.md.sha256
            profiles/*.md.sig
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
